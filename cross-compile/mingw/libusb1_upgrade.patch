The sigrok build references an older libusb1 library version, which
addresses two specific aspects:

  - Presence of an "event abstraction" is desired. Which once was
    available as a branch on top of 1.0.20-rc3, but has gone away
    in the meantime and got archived locally. -- Library versions
    1.0.24 and above may provide that feature under the common API
    but are yet to get verified.

  - For performance reasons the RAW_IO feature is enabled. libusb1
    mainline may provide such an approach later (automatically, after
    checking more conditions for improved reliability), but does not
    in versions up to and including 1.0.25 yet.

Manipulation of the libusb1 configuration in the MXE setup avoids the
necessity for a custom libusb1 build as a step in the sigrok procedure.

Ideally the sigrok build would use libusb1 version 1.0.25+ to benefit
from the many portability and robustness and feature set improvements.
Regardless of which libusb1 version ships with mainline MXE. That is
why this file is called "libusb1_upgrade.patch". Until then it patches
the local archive of the older library version.


Explicitly prepare autotools use between checkout and configuration.

diff --git a/src/libusb1.mk b/src/libusb1.mk
index ab01bf69..53aed36e 100644
--- a/src/libusb1.mk
+++ b/src/libusb1.mk
@@ -19,7 +19,7 @@ define $(PKG)_UPDATE
 endef
 
 define $(PKG)_BUILD
-    cd '$(1)' && ./configure \
+    cd '$(1)' && autoreconf -i && ./configure \
         $(MXE_CONFIGURE_OPTS) \
         CFLAGS=-D_WIN32_WINNT=0x0500
     $(MAKE) -C '$(1)' -j '$(JOBS)' install


Don't use MXE's provided 1.0.24 version. Use an "event abstraction"
enabled older version instead.

diff --git a/src/libusb1.mk b/src/libusb1.mk
index ab01bf69..53aed36e 100644
--- a/src/libusb1.mk
+++ b/src/libusb1.mk
@@ -4,11 +4,11 @@ PKG             := libusb1
 $(PKG)_WEBSITE  := https://libusb.info/
 $(PKG)_DESCR    := LibUsb-1.0
 $(PKG)_IGNORE   :=
-$(PKG)_VERSION  := 1.0.24
-$(PKG)_CHECKSUM := 7efd2685f7b327326dcfb85cee426d9b871fd70e22caa15bb68d595ce2a2b12a
-$(PKG)_SUBDIR   := libusb-$($(PKG)_VERSION)
-$(PKG)_FILE     := libusb-$($(PKG)_VERSION).tar.bz2
-$(PKG)_URL      := https://$(SOURCEFORGE_MIRROR)/project/libusb/libusb-1.0/libusb-$($(PKG)_VERSION)/$($(PKG)_FILE)
+$(PKG)_VERSION  := 1.0.24
+$(PKG)_CHECKSUM := 7efd2685f7b327326dcfb85cee426d9b871fd70e22caa15bb68d595ce2a2b12a
+$(PKG)_SUBDIR   := libusb-$($(PKG)_VERSION)
+$(PKG)_FILE     := libusb-$($(PKG)_VERSION).tar.bz2
+$(PKG)_URL      := https://$(SOURCEFORGE_MIRROR)/project/libusb/libusb-1.0/libusb-$($(PKG)_VERSION)/$($(PKG)_FILE)
 $(PKG)_DEPS     := cc
 
 define $(PKG)_UPDATE


Enable RAW_IO policy on Windows when constraints are met. This assumes
recent libusb1 versions, see https://github.com/libusb/libusb/pull/1069
for details.

diff --git a/src/libusb1-1-fixes.patch b/src/libusb1-1-fixes.patch
new file mode 100644
index 00000000..6cdeb0c4
--- /dev/null
+++ b/src/libusb1-1-fixes.patch
@@ -0,0 +1,31 @@
+commit f341e4a086edd4f45c2db4df892a52ebfd52ac5b
+Author:     Petteri Aimonen <jpa@git.mail.kapsi.fi>
+AuthorDate: 2022-02-11 12:08:01 +0200
+Commit:     Petteri Aimonen <jpa@git.mail.kapsi.fi>
+CommitDate: 2022-02-11 12:08:01 +0200
+
+    WinUSB: Use RAW_IO when transfer size is divisible by 512 bytes
+---
+ libusb/os/windows_winusb.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/libusb/os/windows_winusb.c b/libusb/os/windows_winusb.c
+index a03d6a51216a..a0ac0c609e99 100644
+--- a/libusb/os/windows_winusb.c
++++ b/libusb/os/windows_winusb.c
+@@ -3086,6 +3086,15 @@ static int winusbx_submit_bulk_transfer(int sub_api, struct usbi_transfer *itran
+ 	set_transfer_priv_handle(itransfer, handle_priv->interface_handle[current_interface].dev_handle);
+ 	overlapped = get_transfer_priv_overlapped(itransfer);
+ 
++	if (sub_api == SUB_API_WINUSB)
++	{
++		// Use RAW_IO when transfer size is divisible by 512 bytes.
++		UCHAR policy = (transfer->length % 512 == 0);
++		if (!WinUSBX[sub_api].SetPipePolicy(winusb_handle, transfer->endpoint, RAW_IO, sizeof(UCHAR), &policy)) {
++				usbi_err(TRANSFER_CTX(transfer), "failed to set RAW_IO for endpoint %02X", transfer->endpoint);
++		}
++	}
++
+ 	if (IS_XFERIN(transfer)) {
+ 		usbi_dbg(TRANSFER_CTX(transfer), "reading %d bytes", transfer->length);
+ 		ret = WinUSBX[sub_api].ReadPipe(winusb_handle, transfer->endpoint, transfer->buffer, transfer->length, NULL, overlapped);
